# Sub-Agent System for Vibeship CLI

## Overview

Add a sub-agent pipeline that runs **after** the main build/edit/fix completes. Sub-agents are separate Claude Code calls that review and fix specific quality concerns. Each sub-agent is a focused, single-purpose reviewer.

### Two initial sub-agents:
1. **Architecture Scanner** — always runs after build, reviews code structure
2. **Localization Auditor** — only runs when the project has localization, checks all strings are properly localized

---

## Design Decisions

### Sub-agents run AFTER the main build, not during
- The main build/edit/fix already has 30 turns and handles code generation
- Sub-agents review the output and make targeted fixes
- Each sub-agent gets its own Claude session with a focused prompt and tools
- Sub-agents share the same project directory (they read + edit files in place)

### Conditional execution
- Architecture scanner: always after `build`
- Localization auditor: only when `.xcstrings` or `.lproj` directories exist in the project
- Sub-agents are NOT run after `fix` (fix is already a correction pass)
- Sub-agents ARE run after `edit` (edits may introduce new issues)

### Localization detection for existing projects
- Scan `{projectDir}/{appName}/` for `*.xcstrings` files or `*.lproj` directories
- This works for both new builds (where planner outputs `localizations`) and existing projects

---

## Files Modified

| File | Changes |
|------|---------|
| `cli/internal/orchestration/subagents.go` | **NEW** — Sub-agent definitions, prompts, runner |
| `cli/internal/orchestration/pipeline.go` | Add `runSubAgents()` call after build and edit phases |
| `cli/internal/orchestration/types.go` | Add `SubAgentResult` type |

---

## Detailed Changes

### 1. `cli/internal/orchestration/subagents.go` — NEW

Contains:

**`SubAgent` struct:**
```go
type SubAgent struct {
    Name       string                                      // display name
    Prompt     string                                      // system prompt for the agent
    UserMsg    func(projectDir, appName string) string     // generates the user message
    ShouldRun  func(projectDir, appName string) bool       // condition check
    MaxTurns   int
    Model      string                                      // empty = use pipeline's buildModel()
}
```

**`defaultSubAgents()` function** — returns `[]SubAgent` with the two agents:

**Agent 1: Architecture Scanner** (`architectureScanner`)
- `ShouldRun`: always true
- Prompt: Expert iOS architect. Reviews: file structure matches conventions (Models/, Features/{Name}/, Theme/, App/), @AppStorage wiring (written in child → read at root), dead code (views never referenced), missing #Preview blocks, AppTheme usage (no hardcoded colors), view body complexity (>30 lines → extract computed properties)
- User message: "Review the project architecture and fix any issues. Read the key files, check wiring, and fix problems you find."
- MaxTurns: 10
- Tools: Read, Edit, Glob, Grep (no Write — shouldn't create new files, only fix existing)

**Agent 2: Localization Auditor** (`localizationAuditor`)
- `ShouldRun`: `hasLocalization(projectDir, appName)` — checks for `.xcstrings` files or `.lproj` dirs
- Prompt: Expert iOS localization engineer. Reviews: every user-facing string literal in Swift views has a corresponding key in xcstrings/strings files; no String(localized:) usage; no hardcoded if/else on language code; .id(appLanguage) exists on RootView; layoutDirection is set explicitly for RTL; all xcstrings keys are referenced in code (stale key detection — the exact warning the user mentioned)
- User message: "Audit localization completeness. Read all Swift view files and the localization files. For each user-facing string in code, verify it exists in the localization files. For each key in localization files, verify it's referenced in code. Fix any issues."
- MaxTurns: 15 (needs to read many files)
- Tools: Read, Edit, Glob, Grep, Bash (for xcodebuild check at end)

**`runSubAgents()` method on Pipeline:**
```go
func (p *Pipeline) runSubAgents(ctx context.Context, projectDir, appName string) {
    agents := defaultSubAgents()
    for _, agent := range agents {
        if !agent.ShouldRun(projectDir, appName) {
            continue
        }
        // Show progress
        spinner := terminal.NewSpinner(fmt.Sprintf("Running %s...", agent.Name))
        spinner.Start()

        model := agent.Model
        if model == "" {
            model = p.buildModel()
        }

        resp, err := p.claude.Generate(ctx, agent.UserMsg(projectDir, appName), claude.GenerateOpts{
            AppendSystemPrompt: agent.Prompt,
            MaxTurns:           agent.MaxTurns,
            Model:              model,
            WorkDir:            projectDir,
            AllowedTools:       agenticTools,
        })

        spinner.Stop()
        if err != nil {
            terminal.Warning(fmt.Sprintf("%s: %v", agent.Name, err))
        } else {
            terminal.Success(agent.Name)
            showCost(resp)
        }
    }
}
```

**`hasLocalization()` helper:**
```go
func hasLocalization(projectDir, appName string) bool {
    sourceDir := filepath.Join(projectDir, appName)
    // Check for .xcstrings files
    matches, _ := filepath.Glob(filepath.Join(sourceDir, "**", "*.xcstrings"))
    if len(matches) > 0 { return true }
    // Also check immediate subdirectories
    matches, _ = filepath.Glob(filepath.Join(sourceDir, "*", "*.xcstrings"))
    if len(matches) > 0 { return true }
    // Check for .lproj directories
    entries, _ := os.ReadDir(sourceDir)
    for _, e := range entries {
        if e.IsDir() && strings.HasSuffix(e.Name(), ".lproj") { return true }
    }
    // Check Resources subdirectory
    entries, _ = os.ReadDir(filepath.Join(sourceDir, "Resources"))
    for _, e := range entries {
        if strings.HasSuffix(e.Name(), ".xcstrings") { return true }
        if e.IsDir() && strings.HasSuffix(e.Name(), ".lproj") { return true }
    }
    return false
}
```

### 2. `cli/internal/orchestration/pipeline.go` — Wire sub-agents

**In `Build()`**, after Phase 4 (build+fix) succeeds and before Phase 5 (finalize):
```go
// Phase 4.5: Sub-agent review
p.runSubAgents(ctx, projectDir, appName)
```

**In `Edit()`**, after successful edit and before returning:
```go
// Sub-agent review after edit
appName := filepath.Base(projectDir)
p.runSubAgents(ctx, projectDir, appName)
```

### 3. `cli/internal/orchestration/types.go` — Add SubAgentResult

```go
type SubAgentResult struct {
    Name      string
    Success   bool
    CostUSD   float64
}
```

---

## Sub-Agent Prompts (detailed)

### Architecture Scanner prompt:
```
You are an expert iOS architect reviewing a SwiftUI project for structural quality.

REVIEW CHECKLIST:
1. FILE STRUCTURE: Models/ for data, Features/{Name}/ for views+viewmodels, Theme/ for AppTheme, App/ for entry point
2. @APPSTORAGE WIRING: Any @AppStorage written in child views MUST be read in the @main App and applied on RootView. A toggle that has no visible effect is a critical bug.
3. DEAD CODE: Every View must be reachable from the navigation hierarchy. A view file that is never referenced from any other file is dead code — wire it in or remove it.
4. THEME COMPLIANCE: All colors must come from AppTheme. Grep for hardcoded Color(.blue), Color(.red), Color.orange etc — replace with AppTheme.Colors tokens.
5. #PREVIEW: Every View must have a #Preview block. If missing, add one using sampleData.
6. VIEW COMPLEXITY: If any View body exceeds ~30 lines, extract sections into computed properties.

RULES:
- Read files before editing. Understand the existing patterns.
- Make minimal, targeted fixes. Don't restructure the whole project.
- After fixes, run: xcodegen generate && xcodebuild (build command from CLAUDE.md)
```

### Localization Auditor prompt:
```
You are an expert iOS localization engineer auditing a SwiftUI project.

YOUR MISSION: Ensure every user-facing string is properly localized and every localization key is used.

AUDIT STEPS:
1. Read all .xcstrings or .strings localization files to get the set of KNOWN KEYS
2. Read all .swift files under Features/ and App/ to find user-facing strings
3. For each string literal in Text(), Button(), Label(), .navigationTitle(), Section(), Toggle(), .searchable(prompt:), ContentUnavailableView, alert titles/messages, .accessibilityLabel():
   - Verify the English text exists as a key in the localization files
   - If missing, ADD the key with translations for all supported languages
4. For each key in localization files:
   - Grep the Swift source to verify it's referenced somewhere
   - If not found in any source file, the key is STALE — remove it
5. Check FORBIDDEN patterns:
   - No String(localized:) usage (breaks runtime language switching)
   - No hardcoded if/else on language code for translations
   - No manual translation dictionaries
6. Check ROOT WIRING:
   - .id(appLanguage) MUST exist on RootView in the @main App
   - .environment(\.locale) MUST be set
   - .environment(\.layoutDirection) MUST be set explicitly for RTL
7. After fixes, rebuild to verify no regressions:
   xcodegen generate && xcodebuild -project {AppName}.xcodeproj -scheme {AppName} -destination 'generic/platform=iOS Simulator' -quiet build

XCSTRINGS FORMAT:
The modern .xcstrings file is JSON with this structure:
{
  "sourceLanguage": "en",
  "strings": {
    "Settings": {
      "localizations": {
        "ar": { "stringUnit": { "state": "translated", "value": "الإعدادات" } }
      }
    }
  },
  "version": "1.0"
}
Keys are the English text. English doesn't need an explicit localization entry (it IS the key).
To add a new key, add it to the "strings" object with translations for each supported language.
To remove a stale key, delete it from the "strings" object.
```

---

## User Experience

After build:
```
  ✓ Build complete
  Cost: $0.1234

  ⠋ Running architecture review...
  ✓ Architecture review
  Cost: $0.0123

  ⠋ Running localization audit...     ← only appears if project has localization
  ✓ Localization audit
  Cost: $0.0089

  ✓ OmanDrive is ready!
```

After edit (with localization):
```
  ✓ Changes applied!
  Cost: $0.0567

  ⠋ Running architecture review...
  ✓ Architecture review
  Cost: $0.0045

  ⠋ Running localization audit...
  ✓ Localization audit
  Cost: $0.0034
```

---

## Verification

1. `cd cli && go build ./...` — compiles cleanly
2. `go vet ./...` — no warnings
3. Test build: `vibeship build "todo app"` → architecture scanner runs, no localization agent
4. Test build with localization: `vibeship build "todo app with Arabic"` → both agents run
5. Test edit on localized project: both agents run
6. Test fix: no sub-agents run (fix is already corrective)
